<!doctype html>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Timer — Rest</title>
<style>
  :root{
    /* Bleu océan plus foncé */
    --bg:#013A63;
    --fg:#ffffff;
  }
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
    display:flex; align-items:center; justify-content:center;
    position:relative;
  }
  .wrap{
    text-align:center;
    padding:clamp(16px,6vh,48px);
    display:flex; flex-direction:column; align-items:center;
    gap:clamp(12px, 5vh, 40px);
    max-width:520px; width:92%;
  }
  .phase{ font-size:clamp(35px,6vw,36px); opacity:.95; margin-bottom:12px; font-weight:600 }
  .phase.work{ font-size:clamp(45px,7vw,44px); font-weight:700 }
  .time{ font-size:clamp(48px,14vw,72px); letter-spacing:1px; line-height:1; font-weight:800 }

  /* Signature */
  .brand{
    position:absolute;
    right:14px;
    bottom:10px;
    font-size:13px;
    font-weight:700;
    letter-spacing:.2px;
    opacity:.75;
    user-select:none;
  }
</style>

<div class="wrap">
  <div class="phase" id="phase">Récupération</div>
  <div class="time" id="time">00:00</div>
</div>
<div class="brand">Coach Simon</div>

<script>
  // --- Params envoyés par Glide ---
  const q = new URLSearchParams(location.search);
  const prep = Math.max(0, +q.get('prep')||0);   // secondes de préparation éventuelle
  const dur  = Math.max(0, +q.get('dur')||0);    // secondes de repos
  const mode = (q.get('mode') || 'rest');        // 'rest' par défaut
  const startStr = q.get('start');

  // Option vibration sur les 5 dernières secondes (0/1)
  // ex: &vib=1
  const vibEnabled = (q.get('vib') || '0') === '1';

  // parse start
  function parseStart(s){
    if (!s) return Date.now();
    const d = new Date(s);
    if (!isNaN(d)) return d.getTime();
    const m = s.match(/(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2}):(\d{2})/);
    if (m){
      const [,dd,MM,yyyy,hh,mm,ss] = m;
      return new Date(`${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}`).getTime();
    }
    return Date.now();
  }
  const start = parseStart(startStr);

  const phaseEl = document.getElementById('phase');
  const timeEl  = document.getElementById('time');

  // --- Wake Lock (garder l'écran allumé) ---
  let wakeLock = null;
  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator && !wakeLock) {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener?.('release', () => { wakeLock = null; });
      }
    } catch (e) { console.log('WakeLock error', e); }
  }
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && !wakeLock) requestWakeLock();
  });
  window.addEventListener('click', requestWakeLock, { once: true });
  window.addEventListener('touchstart', requestWakeLock, { once: true });
  requestWakeLock();
  window.addEventListener('beforeunload', () => { try{ wakeLock?.release(); }catch{} });

  // --- Utils ---
  const fmt = (s)=>{
    s = Math.max(0, Math.floor(s));
    const m = Math.floor(s/60).toString().padStart(2,'0');
    const sec = (s%60).toString().padStart(2,'0');
    return `${m}:${sec}`;
  };
  const shortBeep = (freq=1000, dur=120, vol=0.12)=>{
    try{
      const C = window.AudioContext||window.webkitAudioContext;
      const ctx = new C();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type='sine'; o.frequency.value=freq; g.gain.value=vol;
      o.start(); setTimeout(()=>{o.stop(); ctx.close();}, dur);
    }catch(e){}
  };
  const longBeep = (freq=880, dur=320, vol=0.16)=>{
    try{
      const C = window.AudioContext||window.webkitAudioContext;
      const ctx = new C();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type='sine'; o.frequency.value=freq; g.gain.value=vol;
      o.start(); setTimeout(()=>{o.stop(); ctx.close();}, dur);
    }catch(e){}
  };

  const buzz = (pattern)=>{
    if (!vibEnabled) return;
    if (navigator.vibrate) navigator.vibrate(pattern);
  };

  // états pour biper une seule fois par seconde affichée
  let lastPrepDisplay = null;
  let lastRunDisplay  = null;
  let endLongBeepDone = false;

  const tick = ()=>{
    const now = Date.now();
    const elapsed = (now - start)/1000;

    const prepRemain = Math.max(0, prep - elapsed);
    const runRemain  = Math.max(0, prep + dur - elapsed);

    // --- Phase Préparation (optionnelle) ---
    if (prep > 0 && prepRemain > 0) {
      phaseEl.textContent = "Prépare toi pour l'exercice";
      phaseEl.className = "phase";
      const disp = Math.floor(prepRemain);
      timeEl.textContent = fmt(prepRemain);

      if (disp !== lastPrepDisplay) {
        // bip + (option vib) sur les 5 dernières secondes
        if (disp <= 5 && disp >= 1) {
          shortBeep(1000); buzz(50);
        }
        if (disp === 0) {
          longBeep(900, 360, 0.18);
          buzz([80,40,80]);
        }
        lastPrepDisplay = disp;
      }
      return;
    }

    // --- Phase principale (Repos ici) ---
    if (runRemain > 0) {
      phaseEl.textContent = (mode === 'rest') ? "Récupération" : "C'est parti !";
      phaseEl.className   = (mode === 'rest') ? "phase" : "phase work";
      const disp = Math.floor(runRemain);
      timeEl.textContent = fmt(runRemain);

      if (disp !== lastRunDisplay) {
        // bip + (option vib) sur les 5 dernières secondes
        if (disp <= 5 && disp >= 1) {
          shortBeep(1200); buzz(50);
        }
        if (disp === 0) {
          longBeep(880, 420, 0.2);
          buzz([100,60,120]);
          endLongBeepDone = true;
        }
        lastRunDisplay = disp;
      }
      return;
    }

    // --- Terminé ---
    phaseEl.textContent = (mode === 'rest') ? "Repos terminé" : "Terminé";
    phaseEl.className = "phase";
    timeEl.textContent  = "00:00";
    if (!endLongBeepDone) {
      longBeep(880, 420, 0.2);
      buzz([100,60,120]);
      endLongBeepDone = true;
    }
  };

  tick();
  const iv = setInterval(tick, 200);
  setTimeout(()=>clearInterval(iv), 2*60*60*1000);
</script>
