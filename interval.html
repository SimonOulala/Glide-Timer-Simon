<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interval Timer</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#111827;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#22c55e;
      --danger:#ef4444;
      --warn:#f59e0b;
      --barbg:#1f2937;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:radial-gradient(1200px 600px at 50% 20%, rgba(34,197,94,.18), transparent 60%),
                 radial-gradient(900px 500px at 20% 80%, rgba(245,158,11,.12), transparent 55%),
                 var(--bg);
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
    }
    .wrap{
      width:min(680px, 100%);
      background:rgba(17,24,39,.85);
      border:1px solid rgba(255,255,255,.08);
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
      border-radius:16px;
      padding:22px 18px 18px;
      position:relative;
      overflow:hidden;
    }
    .top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }
    .status{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      font-weight:700;
      letter-spacing:.5px;
      width:fit-content;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background:var(--muted);
      box-shadow:0 0 0 4px rgba(156,163,175,.18);
    }
    .meta{
      color:var(--muted);
      font-size:14px;
      line-height:1.25;
    }
    .time{
      font-variant-numeric: tabular-nums;
      font-size: clamp(56px, 10vw, 92px);
      font-weight: 800;
      letter-spacing: -1px;
      text-align:right;
      min-width: 180px;
    }
    .progress{
      height:12px;
      background:var(--barbg);
      border-radius:999px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
      margin: 14px 0 12px;
    }
    .bar{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, rgba(34,197,94,.95), rgba(245,158,11,.90));
      border-radius:999px;
      transition: width .15s linear;
    }
    .controls{
      display:flex;
      gap:10px;
      margin-top:10px;
    }
    button{
      appearance:none;
      border:none;
      border-radius:12px;
      padding:12px 14px;
      font-weight:700;
      cursor:pointer;
      color:var(--text);
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      flex:1;
      transition: transform .05s ease, background .15s ease;
    }
    button:hover{ background:rgba(255,255,255,.09); }
    button:active{ transform: translateY(1px); }
    .btn-primary{
      background:rgba(34,197,94,.18);
      border-color:rgba(34,197,94,.35);
    }
    .btn-warn{
      background:rgba(245,158,11,.16);
      border-color:rgba(245,158,11,.35);
    }
    .err{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(239,68,68,.35);
      background:rgba(239,68,68,.10);
      color:#fecaca;
      font-size:14px;
      display:none;
      white-space:pre-wrap;
    }
    .brand{
      position:absolute;
      right:14px;
      bottom:10px;
      color:rgba(229,231,235,.60);
      font-size:13px;
      font-weight:700;
      letter-spacing:.2px;
      user-select:none;
    }
    .hint{
      color:rgba(156,163,175,.75);
      font-size:12px;
      margin-top:6px;
      text-align:center;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="status">
        <div class="badge" id="phaseBadge">
          <span class="dot" id="phaseDot"></span>
          <span id="phaseText">PRÊT</span>
        </div>
        <div class="meta" id="metaLine">—</div>
      </div>
      <div class="time" id="timeDisplay">00:00</div>
    </div>

    <div class="progress" aria-label="Progression">
      <div class="bar" id="progressBar"></div>
    </div>

    <div class="controls">
      <button class="btn-primary" id="resetBtn" type="button">Reset</button>
      <button class="btn-warn" id="skipBtn" type="button">Skip</button>
    </div>

    <div class="hint" id="hintLine">prep → (travail / récup) × reps → fin</div>
    <div class="err" id="errBox"></div>

    <div class="brand">Coach Simon</div>
  </div>

<script>
(function(){
  const qs = new URLSearchParams(window.location.search);

  const prep = toInt(qs.get('prep'), 0);
  const work = toInt(qs.get('work'), null);
  const rest = toInt(qs.get('rest'), 0);
  const reps = toInt(qs.get('reps'), null);
  const tz   = (qs.get('tz') || '').trim(); // optional

  const errBox = el('errBox');
  const phaseText = el('phaseText');
  const phaseDot  = el('phaseDot');
  const metaLine  = el('metaLine');
  const timeDisplay = el('timeDisplay');
  const progressBar = el('progressBar');

  const resetBtn = el('resetBtn');
  const skipBtn  = el('skipBtn');

  const problems = [];
  if (work === null || work <= 0) problems.push("Paramètre requis invalide : work (secondes de travail, > 0)");
  if (reps === null || reps <= 0) problems.push("Paramètre requis invalide : reps (nombre de répétitions, > 0)");
  if (prep < 0) problems.push("Paramètre invalide : prep (>= 0)");
  if (rest < 0) problems.push("Paramètre invalide : rest (>= 0)");

  if (problems.length){
    showError("❌ URL invalide.\n" + problems.map(p=>"• "+p).join("\n") +
      "\n\nExemple : interval.html?prep=3&work=5&rest=25&reps=10&tz=Europe/Paris&cb=123");
    setPhase("ERREUR", "danger");
    timeDisplay.textContent = "—";
    metaLine.textContent = "Corrige les paramètres URL.";
    progressBar.style.width = "0%";
    resetBtn.disabled = true;
    skipBtn.disabled = true;
    return;
  }

  // Total duration for progress: prep + reps*work + (reps-1)*rest
  const totalSeconds = prep + (reps * work) + (Math.max(0, reps - 1) * rest);

  const PHASE = { PREP:"PREP", WORK:"WORK", REST:"REST", DONE:"DONE" };
  let phase = prep > 0 ? PHASE.PREP : PHASE.WORK;
  let repIndex = 1;
  let remaining = (phase === PHASE.PREP) ? prep : work;

  let lastTickMs = performance.now();

  // Beep helpers
  const shortBeep = (freq=1100, durMs=120, vol=0.12)=>{
    try{
      const C = window.AudioContext||window.webkitAudioContext;
      const ctx = new C();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type='sine'; o.frequency.value=freq; g.gain.value=vol;
      o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, durMs);
    }catch(e){}
  };
  const longBeep = (freq=880, durMs=420, vol=0.2)=>{
    try{
      const C = window.AudioContext||window.webkitAudioContext;
      const ctx = new C();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type='sine'; o.frequency.value=freq; g.gain.value=vol;
      o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, durMs);
    }catch(e){}
  };

  // Track last displayed second per phase so we beep only once per second change
  let lastDispByPhase = { PREP:null, WORK:null, REST:null };

  render();
  const intervalId = setInterval(tick, 100);

  resetBtn.addEventListener('click', () => window.location.reload());
  skipBtn.addEventListener('click', () => { if (phase !== PHASE.DONE) remaining = 0; });

  function tick(){
    const now = performance.now();
    const dt = (now - lastTickMs) / 1000;
    lastTickMs = now;

    remaining = Math.max(0, remaining - dt);

    const totalRemaining = remainingGlobalSmooth();
    const progress = totalSeconds > 0 ? (1 - (totalRemaining / totalSeconds)) : 1;
    progressBar.style.width = (Math.max(0, Math.min(1, progress)) * 100).toFixed(2) + "%";

    if (remaining <= 0.001) advance();
    render();
  }

  function advance(){
    if (phase === PHASE.PREP){
      phase = PHASE.WORK;
      remaining = work;
      return;
    }
    if (phase === PHASE.WORK){
      if (repIndex >= reps){
        phase = PHASE.DONE;
        remaining = 0;
        onDone();
        return;
      }
      if (rest > 0){
        phase = PHASE.REST;
        remaining = rest;
      } else {
        repIndex++;
        phase = PHASE.WORK;
        remaining = work;
      }
      return;
    }
    if (phase === PHASE.REST){
      repIndex++;
      phase = PHASE.WORK;
      remaining = work;
      return;
    }
  }

  function onDone(){
    clearInterval(intervalId);
    setPhase("FIN", "accent");
    phaseDot.style.boxShadow = "0 0 0 6px rgba(34,197,94,.18)";
    timeDisplay.textContent = "00:00";
    metaLine.textContent = `Terminé — ${reps} répétitions`;
    progressBar.style.width = "100%";
    // Optional: long beep at the very end (once)
    longBeep(880, 520, 0.22);
  }

  function render(){
    if (phase === PHASE.PREP){
      setPhase("PRÊT", "warn");
      metaLine.textContent = metaText();
    } else if (phase === PHASE.WORK){
      setPhase("TRAVAIL", "accent");
      metaLine.textContent = metaText();
    } else if (phase === PHASE.REST){
      setPhase("RÉCUP", "muted");
      metaLine.textContent = metaText();
    }

    const disp = Math.ceil(remaining);
    timeDisplay.textContent = formatMMSS(disp);

    // --- Beeps on last 3 seconds for WORK and REST only ---
    if (phase === PHASE.WORK || phase === PHASE.REST){
      const last = lastDispByPhase[phase];
      if (disp !== last){
        // beep on 3..1 only
        if (disp <= 3 && disp >= 1){
          // Different pitch so user senses the phase
          shortBeep(phase === PHASE.REST ? 900 : 1200, 120, 0.12);
        }
        lastDispByPhase[phase] = disp;
      }
    } else {
      // keep PREP tracking but no beep requested
      lastDispByPhase[phase] = disp;
    }
  }

  function metaText(){
    const repPart = `Répétition ${repIndex}/${reps}`;
    const spec = `work ${work}s • rest ${rest}s` + (prep>0 ? ` • prep ${prep}s` : "");
    const tzPart = tz ? ` • ${tz}` : "";
    return repPart + " — " + spec + tzPart;
  }

  function setPhase(label, kind){
    phaseText.textContent = label;

    if (kind === "accent"){
      phaseDot.style.background = "var(--accent)";
      phaseDot.style.boxShadow = "0 0 0 4px rgba(34,197,94,.18)";
    } else if (kind === "warn"){
      phaseDot.style.background = "var(--warn)";
      phaseDot.style.boxShadow = "0 0 0 4px rgba(245,158,11,.18)";
    } else if (kind === "danger"){
      phaseDot.style.background = "var(--danger)";
      phaseDot.style.boxShadow = "0 0 0 4px rgba(239,68,68,.18)";
    } else {
      phaseDot.style.background = "var(--muted)";
      phaseDot.style.boxShadow = "0 0 0 4px rgba(156,163,175,.18)";
    }
  }

  function remainingGlobalSmooth(){
    if (phase === PHASE.DONE) return 0;

    if (phase === PHASE.PREP){
      return remaining + (reps * work) + (Math.max(0, reps - 1) * rest);
    }
    if (phase === PHASE.WORK){
      const repsLeftAfterThisWork = reps - repIndex;
      const restsLeft = Math.max(0, repsLeftAfterThisWork);
      return remaining + (repsLeftAfterThisWork * work) + (restsLeft * rest);
    }
    if (phase === PHASE.REST){
      const repsLeftIncludingNextWork = reps - repIndex;
      const restsLeftAfterThisRest = Math.max(0, repsLeftIncludingNextWork - 1);
      return remaining + (repsLeftIncludingNextWork * work) + (restsLeftAfterThisRest * rest);
    }
    return 0;
  }

  function el(id){ return document.getElementById(id); }
  function toInt(v, fallback){
    if (v === null || v === undefined) return fallback;
    const n = parseInt(String(v), 10);
    return Number.isFinite(n) ? n : fallback;
  }
  function formatMMSS(total){
    if (!Number.isFinite(total)) return "—";
    const t = Math.max(0, total|0);
    const mm = String(Math.floor(t/60)).padStart(2,'0');
    const ss = String(t%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }
  function showError(msg){
    errBox.style.display = "block";
    errBox.textContent = msg;
  }
})();
</script>
</body>
</html>
